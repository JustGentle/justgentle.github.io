<!DOCTYPE html>
<html>

<head>
  <title>Just扫雷</title>
  <style>
    #parent {
      position: relative;

      /* noselect */
      -webkit-touch-callout: none;
      /* iOS Safari */
      -webkit-user-select: none;
      /* Chrome/Safari/Opera */
      -khtml-user-select: none;
      /* Konqueror */
      -moz-user-select: none;
      /* Firefox */
      -ms-user-select: none;
      /* Internet Explorer/Edge */
      user-select: none;
      /* Non-prefixed version, currently not supported by any browser */
    }

    #parent button {
      border: 1px solid gray;
      background: white;
      color: black;
      padding: 5px;
    }

    #parent button:hover {
      border: 1px solid lightcyan;
      background: lightgray;
      color: blue;
    }

    #layer {
      position: absolute;
      background: rgba(0, 0, 0, 0.5);
      width: 100%;
      height: 100%;
      top: 0;
      left: 0;
      text-align: center;
    }

    #layer.pause {
      background: black;
    }

    #layer .layerCenter {
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      -webkit-transform: translate(-50%, -50%);
      -moz-transform: translate(-50%, -50%);
    }

    #layer span {
      color: cyan;
    }

    #layer button {
      margin-top: 10px;
    }

    #tools {
      width: 100%;
    }

    #tools #time {
      color: red;
      text-align: right;
    }

    #tools #state {
      font-weight: bold;
      color: red;
      text-align: center;
    }

    #tools #mine {
      color: red;
      text-align: left;
    }

    #game table {
      border-spacing: 0;
    }

    #game td {
      box-sizing: border-box;
      background: lightgray;
      border: 1px solid gray;
      text-align: center;
      vertical-align: middle;
    }

    #game td.normal {
      border-left: 2px solid #ededed;
      border-top: 2px solid #ededed;
      border-right: 2px solid gray;
      border-bottom: 2px solid gray;
    }

    #game td.normal:hover {
      border-left: 2px solid gray;
      border-top: 2px solid gray;
      border-right: 2px solid #ededed;
      border-bottom: 2px solid #ededed;
    }

    #game td.mark {
      font-weight: bold;
      border-left: 2px solid #ededed;
      border-top: 2px solid #ededed;
      border-right: 2px solid gray;
      border-bottom: 2px solid gray;
    }

    #game td.mark.flag::after {
      color: red;
      content: '!';
    }

    #game td.mark.nosure::after {
      content: '?';
    }

    #game td.number {
      font-weight: bold;
    }

    #game td.number.d1 {
      color: blue;
    }

    #game td.number.d2 {
      color: green;
    }

    #game td.number.d3 {
      color: red;
    }

    #game td.number.d4 {
      color: darkblue;
    }

    #game td.number.d5 {
      color: darkred;
    }

    #game td.number.d6 {
      color: darkcyan;
    }

    #game td.number.d7 {
      color: black;
    }

    #game td.number.d8 {
      color: gray;
    }

    #game td.mine::after {
      content: '✪'
    }

    #game td.mine.boom {
      color: red;
    }
  </style>
</head>

<body>
  <div id="parent">
    <div id="tools">
      <table style="width:100%">
        <tr>
          <td colspan="3">
            <input type="radio" name="action" id="openAction" value="open" checked />翻开
            <input type="radio" name="action" id="markAction" value="mark" />标记
            <button id="pauseBtn">暂停</button>
          </td>
        </tr>
        <tr>
          <td id="mine"></td>
          <td id="state"></td>
          <td id="time"></td>
        </tr>
      </table>
    </div>
    <div id="game"></div>
    <div id="layer" hidden>
      <div id="action" class="layerCenter" hidden>
        <button name="backBtn">返回</button><br />
        <button id="openBtn">翻开</button><br />
        <button id="openAroundBtn">翻开周围</button><br />
        <button id="markBtn">标记</button>
      </div>
      <div id="stop" class="layerCenter" hidden>
        <span id="stopState">结束</span><br />
        <button name="backBtn">返回</button><br />
        <button name="newGameBtn">新游戏</button><br />
        <button name="restartBtn">重新开始(地雷不变)</button>
      </div>
      <div id="pause" class="layerCenter" hidden>
        <span id="pauseState">暂停</span><br />
        <button name="backBtn">返回</button><br />
        <button name="newGameBtn">新游戏</button><br />
        <button name="restartBtn">重新开始(地雷不变)</button>
      </div>
    </div>
  </div>
  <script type="text/javascript">
    Object.prototype.longClick = function (callback, time) {
      if (!time) time = 500;
      if (/Android|webOS|iPhone|iPod|BlackBerry|iPad|IEMobile|Nexus/i.test(navigator.userAgent)) {
        this.addEventListener('touchstart', function ($event) {
          var a = setTimeout(callback, time, $event)
          this.addEventListener('touchend', function () {
            clearTimeout(a)
          })
        })
      } else {
        this.addEventListener('mousedown', function ($event) {
          var a = setTimeout(callback, time, $event)
          this.addEventListener('mouseup', function () {
            clearTimeout(a)
          })
        })
      }
    }

    var classNames = {
      normal: 'normal',
      number: 'number',
      mine: 'mine',
      boom: 'boom',
      mark: 'mark',
      flag: 'mark flag',
      nosure: 'mark nosure',
      pause: 'pause'
    };
    var states = {
      loading: '加载中...',
      newGame: '新游戏',
      playing: '游戏中',
      pause: '暂停',
      win: '胜利！',
      fail: '失败！'
    }
    var elems = {
      markAction: null,
      pauseBtn: null,

      mine: null,
      state: null,
      time: null,

      timer: null,

      layer: null,
      layerAction: null,
      openBtn: null,
      openAroundBtn: null,
      markBtn: null,
      layerStop: null,
      stopState: null,
      layerPause: null,
      pauseState: null,

      layerCell: null,

      game: null,

      cell2elem: function (cell) {
        return document.getElementById('td' + cell);
      },
      elem2cell: function (elem) {
        if (!elem) return 0;
        return Number(elem.getAttribute('n'));
      },
      elemIsNumber: function (elem, className) {
        className = className || classNames.number;
        return new RegExp('\\b' + className + '\\b').test(elem.className);
      },
      init: function () {
        this.markAction = document.getElementById('markAction');
        this.pauseBtn = document.getElementById('pauseBtn');
        this.pauseBtn.onclick = gamePause;

        this.mine = document.getElementById('mine');
        this.state = document.getElementById('state');
        this.time = document.getElementById('time');

        this.layer = document.getElementById('layer');
        this.layerAction = document.getElementById('action');
        this.openBtn = document.getElementById('openBtn');
        this.openAroundBtn = document.getElementById('openAroundBtn');
        this.markBtn = document.getElementById('markBtn');
        this.layerStop = document.getElementById('stop');
        this.stopState = document.getElementById('stopState');
        this.layerPause = document.getElementById('pause');
        this.pauseState = document.getElementById('pauseState');

        this.game = document.getElementById('game');

        //layer事件
        elems.openBtn.onclick = function () {
          elems.layer.hidden = true;
          cellClick({ cell: elems.layerCell, mark: false });
          elems.layerCell = null;
        };
        elems.openAroundBtn.onclick = function(){
          elems.layer.hidden = true;
          openAround(elems.layerCell);
          elems.layerCell = null;
        }
        elems.markBtn.onclick = function () {
          elems.layer.hidden = true;
          cellClick({ cell: elems.layerCell, mark: true });
          elems.layerCell = null;
        };

        var backBtns = document.getElementsByName('backBtn');
        for (let i = 0; i < backBtns.length; i++) {
          backBtns[i].onclick = gameBack;
        }

        var layerNewGame = function () {
          newGame();
          gameBack();
        };
        var newGameBtns = document.getElementsByName('newGameBtn');
        for (let i = 0; i < newGameBtns.length; i++) {
          newGameBtns[i].onclick = layerNewGame;
        }

        var layerRestart = function () {
          newGame(true);
          gameBack();
        };
        var restartBtns = document.getElementsByName('restartBtn');
        for (let i = 0; i < restartBtns.length; i++) {
          restartBtns[i].onclick = layerRestart;
        }
      }
    }

    var options = {
      mineSize: 30,

      state: states.loading,

      cells: [],
      mines: [],
      opens: [],
      flags: [],

      isMine: function (cell) {
        return options.mines.indexOf(cell) >= 0;
      },
      isOpen: function (cell) {
        return options.opens.indexOf(cell) >= 0;
      },
      isFlag: function (cell) {
        return options.flags.indexOf(cell) >= 0;
      },

      wins: [],
      fails: []
    };
    var settings = {
      hCount: 9,
      vCount: 9,
      mCount: 10
    };
    var tools = {
      _mine: 0,
      _state: states.loading,
      _time: 0,

      get mine() { return this._mine; },
      set mine(v) { this._mine = v; elems.mine.innerText = '✪' + v; },

      get state() { return this._state; },
      set state(v) { this._state = v; elems.state.innerText = v; },

      get time() { return this._time; },
      set time(v) { this._time = v; elems.time.innerText = v + '秒'; },

      backState: null,

      thisGameTime: 0,
      thisGameTimed: 0,
      calcGameTime: function () {
        var now = new Date().getTime();
        if (this.thisGameTime) this.thisGameTimed += now - this.thisGameTime;

        this.thisGameTime = tools.state === states.playing ? now : 0;
        this.time = parseInt(this.thisGameTimed / 1000);
        return this.thisGameTimed;
      }
    }

    var newGame = function (restart) {
      tools.state = states.loading;

      //数据重置
      tools.backState = null;
      elems.timer && clearInterval(elems.timer);
      tools.time = tools.thisGameTimed = tools.thisGameTime = 0;
      tools.mine = settings.mCount;
      options.mines = restart ? options.mines : [];
      options.cells = [];
      options.opens = [];
      options.flags = [];

      //画面重置
      var game = elems.game;
      var table = document.createElement('table');
      var cell = 0;
      for (let r = 0; r < settings.vCount; r++) {
        var tr = document.createElement('tr');
        tr.id = "tr" + r;
        for (let c = 0; c < settings.hCount; c++) {
          var td = document.createElement('td');
          td.id = "td" + ++cell;
          td.style.width = options.mineSize + "px";
          td.style.height = options.mineSize + "px";
          td.className = classNames.normal;
          td.setAttribute('n', cell);
          td.onclick = cellClick;
          td.longClick(cellHold);
          tr.appendChild(td);
          options.cells.push(cell);
        }
        table.appendChild(tr);
      }
      game.innerHTML = "";
      game.appendChild(table);
      document.body.style.width = options.mineSize * settings.hCount + 'px';

      tools.state = states.newGame;
    }
    var gameStart = function (startCell) {
      tools.state = states.loading;

      if (options.cells.length < settings.mCount) {
        tools.state = '设置错误:地雷数量过多!';
        return;
      }

      if (!options.mines.length) {
        //布雷(开始游戏点击位置必须非雷)
        options.mines = [];
        var cells = options.cells.concat();
        while (options.mines.length < settings.mCount) {
          var index = randomInt(0, cells.length - 1);
          var cell = cells[index];
          cells.splice(index, 1);
          if (!startCell || cell !== startCell)
            options.mines.push(cell);
        }
      }

      elems.timer && clearInterval(elems.timer);
      elems.timer = setInterval(function () { tools.time++; }, 1000);

      tools.state = states.playing;
      tools.calcGameTime();
    }
    var gameOver = function (cell) {
      tools.state = states.loading;

      elems.timer && clearInterval(elems.timer);
      tools.calcGameTime();
      options.fails.push(Number(tools.time));
      //显示所有雷
      for (let i = 0; i < options.mines.length; i++) {
        var mine = options.mines[i];
        var elem = elems.cell2elem(mine);
        elem.className = classNames.mine;
        //爆炸的雷
        if (mine === cell) elem.className += " " + classNames.boom;
      }

      tools.state = states.fail;
      showLayer();
    }
    var gameWin = function (cell) {
      tools.state = states.loading;
      elems.timer && clearInterval(elems.timer);
      tools.calcGameTime();
      options.wins.push(Number(tools.time));
      tools.state = states.win;
      showLayer();
    }
    var gamePause = function () {
      tools.backState = tools.state;
      tools.state = states.pause;
      tools.calcGameTime();
      showLayer();
    }
    var gameBack = function () {
      elems.layer.hidden = true;
      elems.layerCell = null;
      if (tools.backState) {
        tools.state = tools.backState;
        tools.backState = null;
      }
      tools.calcGameTime();
    }

    var cellHold = function ($event) {
      elems.layerCell = elems.elem2cell($event.srcElement);
      showLayer();
    }
    var cellClick = function ($event) {
      if (checkNew()) return;

      var cell = $event.cell || elems.elem2cell($event.srcElement);
      checkStart(cell);

      var checked = typeof $event.mark === 'undefined' ? elems.markAction.checked : $event.mark;
      if (checked) {
        mark(cell);
      } else {
        open(cell);
      }
    }

    var showLayer = function () {
      switch (tools.state) {
        case states.newGame:
        case states.win:
        case states.fail:
          //结束
          elems.layer.className = "";
          elems.stopState.innerHTML = '【' + tools.state + '】<br/>' + new Number(tools.thisGameTimed / 1000).toFixed(2) + '秒';
          elems.layerAction.hidden = elems.layerPause.hidden = true;
          elems.layerStop.hidden = false;
          break;
        case states.pause:
          //暂停
          elems.layer.className = classNames.pause;
          elems.pauseState.innerText = '【' + tools.state + '】';
          elems.layerAction.hidden = elems.layerStop.hidden = true;
          elems.layerPause.hidden = false;
          break;
        case states.playing:
          //操作
          elems.layer.className = "";
          elems.layerPause.hidden = elems.layerStop.hidden = true;
          var elem = canOpen(elems.layerCell);
          elems.openBtn.hidden = !elem;
          elem = canOpenAround(elems.layerCell);
          elems.openAroundBtn.hidden = !elem;
          elem = canMark(elems.layerCell);
          elems.markBtn.hidden = !elem;
          elems.layerAction.hidden = false;
          break;
        default:
          elems.layerCell = null;
          return;
      }
      elems.layer.hidden = false;
    }

    var mark = function (cell) {
      var elem = canMark(cell);
      if (!elem) return;
      switch (elem.className) {
        case classNames.flag:
          elem.className = classNames.nosure;
          var i = options.flags.indexOf(cell);
          if(i >=0 ) options.flags.splice(i, 1);
          tools.mine++;
          break;
        case classNames.nosure:
          elem.className = classNames.normal;
          break;
        case classNames.normal:
          elem.className = classNames.flag;
          options.flags.push(cell);
          tools.mine--;
          break;
        default:
          break;
      }
    }
    var canMark = function (cell) {
      var elem = elems.cell2elem(cell);
      if (!elem) return false;
      if (tools.state !== states.playing) return false;
      if (elems.elemIsNumber(elem)) return false;
      return elem;
    }

    var open = function (cell) {
      var elem = canOpen(cell);
      if (!elem) return;
      options.opens.push(cell);
      var count = getMineCount(cell);
      if (count < 0) {
        gameOver(cell);
        return;
      } else if (count === 0) {
        elem.className = classNames.number;
        var around = getAroundCells(cell);
        for (let i = 0; i < around.length; i++) {
          open(around[i]);
          if (tools.state !== states.playing) return;
        }
      } else if (!!count) {
        elem.className = classNames.number + " d" + count;
        elem.innerHTML = count;
      }
      checkWin();
    }
    var canOpen = function (cell) {
      var elem = elems.cell2elem(cell);
      if (!elem) return false;
      if (tools.state !== states.playing) return false;
      if (elem.className !== classNames.normal) return false;
      return elem;
    }
    
    var openAround = function (cell) {
      var around = canOpenAround(cell);
      if (!around) return;
      for (let i = 0; i < around.length; i++) {
        open(around[i]);
      }
    }
    var canOpenAround = function (cell) {
      var elem = elems.cell2elem(cell);
      if (!elem) return false;
      if (tools.state !== states.playing) return false;
      if (!elems.elemIsNumber(elem)) return false;

      var i = 0;
      var around = getAroundCells(cell);
      var count = around.length;
      while (i < around.length) {
        if (options.isFlag(around[i])) {
          around.splice(i, 1);
        } else {
          i++;
        }
      }
      //标记雷数与数字不符
      count -= around.length;
      if (count.toString() !== elem.innerText)
        return null;

      //返回需要翻开的位置  
      return around;
    }

    var checkNew = function () {
      if (tools.state !== states.newGame && tools.state !== states.playing) {
        newGame();
        return true;
      }
      return false;
    }
    var checkStart = function (cell) {
      if (tools.state === states.newGame) {
        gameStart(cell);
        return true;
      }
      return false;
    }
    var checkWin = function () {
      if (tools.state !== states.playing) return false;
      if (options.opens.length + settings.mCount === options.cells.length) {
        gameWin();
        return true;
      }
      return false;
    }

    var getMineCount = function (cell) {
      if (options.isMine(cell)) return -1;

      var count = 0;
      var around = getAroundCells(cell);
      for (let i = 0; i < around.length; i++) {
        if (options.isMine(around[i])) count++;
      }
      return count;
    }
    var getAroundCells = function (cell) {
      var around = [];
      var row = cell / settings.hCount;
      var col = cell % settings.hCount;
      if (row > 1) {
        around.push(cell - settings.hCount);
        if (col > 1)
          around.push(cell - settings.hCount - 1);
        if (col < settings.hCount)
          around.push(cell - settings.hCount + 1);
      }
      if (col > 1)
        around.push(cell - 1);
      if (col < settings.hCount)
        around.push(cell + 1);
      if (row < settings.vCount) {
        around.push(cell + settings.hCount);
        if (col > 1)
          around.push(cell + settings.hCount - 1);
        if (col < settings.hCount)
          around.push(cell + settings.hCount + 1);
      }
      return around;
    }

    var randomInt = function (min, max) {
      switch (arguments.length) {
        case 1:
          return parseInt(Math.random() * min + 1, 10);
          break;
        case 2:
          return parseInt(Math.random() * (max - min + 1) + min, 10);
          break;
        default:
          return 0;
          break;
      }
    }

    var init = function () {
      elems.init();
      newGame();
    }
    document.onload = init();
  </script>
</body>

</html>